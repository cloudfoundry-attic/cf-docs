---
title: Writing a v2 Cloud Foundry Service
---

**Note:** The v2 Services API is still in development. The API and this documentation is subject to change.

There are two versions of the Cloud Foundry Services API. This page documents v2. For information about v1 of the API see [Writing a v1 Cloud Foundry Service](writing-service.html).

## <a id='api-changes'></a>What's New in Services API v2 ##

The key changes in v2 of the Services API are:

* Terminology change --- In the v2 Services API, what used to be called a service gateway is referred to as a service broker.
* Unidirectional RESTful HTTP messages --- The Cloud Controller initiates all communication with brokers, so a broker can run standalone.
* Easier catalog management and orphan detection --- This functionality is improved, and moved from the broker to the Cloud Controller.
* Consistent naming --- API endpoints and fields are consistently named.
* Orphan avoidance --- Orphan service instances and bindings are prevented to the extent possible, and automatically removed, when necessary.

## <a id='futures'></a>Upcoming API Changes ##
Changes to the API that are under consideration include the addition of endpoints and the addition of new fields to existing messages. Existing endpoints and fields will not be removed or renamed. Potential changes include:

* New optional endpoints, or new HTTP methods for existing endpoints, may be added to enable support for features such as snapshots, backups, updating instances, and updating bindings. It is expected that brokers will export some listings of their optional capabilities in the catalog.

* New fields may be added to existing request/response messages. These fields must be optional, and should be ignored by clients and servers that do not understand them.

## <a id='api-overview'></a>API Overview ##

The Cloud Foundry services API defines the contract between the Cloud Controller and the service broker. The broker is expected to implement several HTTP (or HTTPS) endpoints underneath a URI prefix. A single service can only be provided by a single broker URL, but horizontal scalability and load balancing allows for multiple redundant brokers. A broker can also offer multiple services.

<%= image_tag("../../../../images/v2services.png", :width =>"960", :height =>"720", :style => 'background-color:#fff') %>

## <a id='api-version-header'></a>API Version Header ##


Requests from the Cloud Controller to the broker contain a header that defines the version number of the Broker API that Cloud Controller will use. This header will be useful in future minor revisions of the API, to allow brokers to reject requests from Cloud Controllers that they do not understand. While minor API revisions will always be additive, it is possible that brokers will come to depend on a feature that was added after 2.0, so they may use this header to reject the request. Error messages from the broker in this situation should inform the operator of what the required and actual version numbers are, so that an operator can go upgrade Cloud Controller and resolve the issue. A broker should respond with a `412 Precondition Failed` message when rejecting a request.

The version numbers are in the format `MAJOR.MINOR`, using semantic versioning such that 2.9 comes before 2.10. An example of this header, as of publication time is:

`X-Broker-Api-Version: 2.0`


## <a id='authentication'></a>Authentication ##

Cloud Controller (final release v145+) authenticates with the Broker using HTTP basic authentication (the `Authentication:` header) on every request, and will reject any broker registrations that do not contain a username and password. The broker is responsible for checking the username and password and returning a `403 Forbidden` message if they are invalid. Cloud Controller supports connecting to a broker using SSL if additional security is desired.


## <a id='catalog-mgmt'></a>Catalog Management ##

The first endpoint that a broker must implement is the service catalog. Cloud Controller will initially fetch this endpoint from all brokers and make adjustments to the user-facing service catalog stored in the Cloud Controller database. If the catalog fails to initially load or validate, Cloud Controller will not allow the operator to add the new broker, and should give a meaningful error message. Cloud Controller will also update the catalog whenever a broker is updated, so you can use `update-service-broker` with no changes to force a catalog refresh.

When Cloud Controller fetches a catalog from a broker, it will compare the `unique_id` for services and plans with what is in the  Cloud Controller database. If a service or plan in the broker catalog has a `unique_id` which is not present in the database, a new record will be added to the database. If services or plans in the database are found with `unique_id`s that match the broker catalog, Cloud Controller will update update the records to match the broker’s catalog.

If the database has plans which are not found in the broker catalog, and there are no associated service instances, Cloud Controller will remove these plans from the database. If there are provisioned instances, the plan will be marked “inactive” and will no longer be visible in the marketplace catalog or be provisionable. Cloud Controller will then delete services that do not have associated plans from the database.


`GET /v2/catalog`

<table>

<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>services*</td>
  <td>array-of-objects</td>
  <td>Schema of service objects defined below:</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;id*</td>
  <td>string</td>
  <td>An identifier, unique within the broker, used to correlate this service in future requests to the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;description*</td>
  <td>string</td>
  <td>A short description of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;bindable*</td>
  <td>boolean</td>
  <td>Whether the service can be bound to applications. Defaults to true.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;tags</td>
  <td>array-of-strings</td>
  <td>A list of permissions that the user would have to give the service, if they provision it. The only permission currently supported is <tt>syslog_drain<tt>. </td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;metadata</td>
  <td>object</td>
  <td>A list of metadata for a service offering. For more information, see <a href="https://docs.google.com/a/gopivotal.com/document/d/19bfM4H1NL4Z4Qj1jYCF6czQnSzxmq96-iuVKHJ7EZ3M/">Service Metadata</a>.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;requires</td>
  <td>array-of-strings</td>
  <td>A list of permissions that the user would have to give the service, if they provision it. The only permission currently supported is <tt>syslog_drain</tt>. </td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;plans*</td>
  <td>array-of-objects
</td>
  <td>A list of plans for this service, schema defined below:</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id*</td>
  <td>string</td>
  <td>An identifier, unique within the broker, used to correlate this plan in future requests to the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the plan that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description*</td>
  <td>string</td>
  <td>IA short description of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata</td>
  <td>object</td>
  <td>A list of metadata for a service plan. For more information, see <a href="https://docs.google.com/a/gopivotal.com/document/d/19bfM4H1NL4Z4Qj1jYCF6czQnSzxmq96-iuVKHJ7EZ3M/">Service Metadata</a>.</td>
</tr>
</tbody>
</table>

**Example response**

<pre class="terminal">
{
  "services": [{
    "id": "service-guid-here",
    "name": "MySQL",
    "description": "A MySQL-compatible relational database",
    "plans": [{
      "id": "plan1-guid-here",
      "name": "small",
      "description": "A small shared database with 100mb storage quota and 10 connections"
    },{
      "id": "plan2-guid-here",
      "name": "large",
      "description": "A large dedicated database with 10GB storage quota, 512MB of RAM, and 100 connections"
    }]
  }]
}
</pre>

## <a id='provisioning'></a>Provisioning ##

When the broker receives a provision request from Cloud Controller, it should synchronously take whatever action is necessary to create a new service resource for the developer. The result of provisioning varies by service type, although there are a few common actions that work for many services. For a MySQL service, provisioning could result in:

* An empty dedicated `mysqld` process running on its own VM.
* An empty dedicated `mysqld` process running in a lightweight container on a shared VM.
* An empty dedicated `mysqld` process running on a shared VM.
* An empty dedicated database, on an existing shared running `mysqld`.
* A database with business schema already there.
* A copy of a full database, for example a QA database that is a copy of the production database.

For non-data services, provisioning could just mean getting an account on an existing system.

`PUT /v2/service_instances/:id`

**In this API, the `:id` of a service instance is provided by the Cloud Controller**. This ID will be used for future requests (bind and unprovision), so the broker must use it to correlate the resource it creates.

<table>
<thead>
<tr>
  <th>Request field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>The ID of the service within the catalog above. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>The ID of the plan within the above service (from the catalog endpoint) that the user would like provisioned. Because plans have identifiers unique to a broker, this is enough information to determine what to provision.</td>
</tr>
<tr>
  <td>organization_guid*</td>
  <td>string</td>
  <td>The Cloud Controller GUID of the organization under which the service is to be provisioned. Although most brokers will not use this field, it could be helpful in determining data placement or applying custom business rules.</td>
</tr>
<tr>
  <td>space_guid*</td>
  <td>string</td>
  <td>Similar to organization_guid, but for the space.</td>
</tr>
</tbody>
</table>

Brokers are expected to respond with `201 Created` with the response body from the table below. They can also return `409 Conflict` if there is already a provisioned resource at this URL. Since this endpoint cannot be used to update resource parameters, brokers must return 409 if a conflicting request is made. Ideally, a non-conflicting request (duplicate ID and params) would return 200, but brokers may simply return 409 for a duplicate ID.  If they respond with any other code, CC will assume that the provision request failed and inform the user.

<table>
<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>dashboard_url</td>
  <td>string</td>
  <td>The URL of a web-based management user interface for the service instance. This optional URL allows space developers to visit a friendly management console for this instance. The URL should contain enough information to identify the resource being accessed ("9189kdfsk0vfnku" in the example below), and potentially the credentials to access that resource ("access_token=3hjdsnqadw487232lp" below). For more information, see <a href="https://docs.google.com/a/gopivotal.com/document/d/1ojU5lFgVcLf9BCKIO481xdweFAb-Y3Vj1CM6KhmqSis/edit#heading=h.z2jbskafu6z8">Authenticating a Service Using the dashboard_url</a>.</td>
</tr>
</tboby>
</table>

**Example response**

<pre class="terminal">
{
 "dashboard_url": "http://mongomgmthost/databases/9189kdfsk0vfnku?access_token=3hjdsnqadw487232lp"
}
</pre>

## <a id='binding'></a>Binding ##

When the broker receives a bind request from the Cloud Controller, it should take whatever action is necessary to generate a way for an application to utilize the already-provisioned resource. Not all services must be bindable --- some derive their value just from being provisioned. Applications should be issued different credentials when possible, so that revoking one bound application's access does not affect others. Bind can mean different things depending on the service. Here are some examples for MySQL:

* New random user credentials are generated for the existing database.
* A single set of credentials are returned for every bind to the same database.

`PUT /v2/service_instances/:instance_id/service_bindings/:id`

Note that the `:id` of a service binding is provided by the Cloud Controller. `:instance_id` is the ID from a previously provisioned service instance; it will be used for future unbind requests, so the broker must use it to correlate the resource it creates.

<table>
<thead>
<tr>
  <th>Request Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog. Not required, but the broker could make use of this to locate the resource.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog. Not required, but the broker could make use of this to locate the resource.</td>
</tr>
</tbody>
</table>

Brokers are expected to respond with `200 OK` or `201 Created` with the response body from the table below. They can also return `409 Conflict` if there is already a binding at the URL. Since this endpoint cannot be used to update resources, a broker must return a 409 if a non-identical request is made. If a broker responds with any other code, Cloud Controller will assume that the binding request failed and inform the user.

<table>
<thead>
<tr>
  <th>Response Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>credentials*</td>
  <td>object</td>
  <td>A free-form hash of credentials that the bound application can use to access the service. Use of a `uri` field (such as `mysql://user:password@host:port/dbname`) is recommended when possible, but it is often useful to provide individual credentials components such as hostname, port, username, and password.</td>
</tr>
<tr>
  <td>syslog_drain_url</td>
  <td>string</td>
  <td>A URL to which Cloud Foundry should drain logs to for the bound application. The <tt>syslog_drain</tt> permission is required for logs to be automatically wired to applications.</td>
</tr>
</tbody>
</table>

**Example response**

<pre class="terminal">
	{
	  "credentials": {
	    "uri": "mysql://mysqluser:pass@mysqlhost:3306/dbname",
	    "username": "mysqluser",
	    "password": "pass",
	    "host": "mysqlhost",
	    "port": 3306,
	    "database": "dbname"
	  }
	}
</pre>

## <a id='unbinding'></a>Unbinding ##

When a broker receives an unbind request from Cloud Controller, it should delete any resources it created in bind. Usually this means that an application immediately cannot access the resource.

`DELETE /v2/service_instances/:instance_id/service_bindings/:id`

The `:id` in the URL is the identifier returned in by the broker during a bind response. The request has no body, because DELETE requests generally do not have bodies. It does provide these query string params as useful hints for brokers:

<table>
<thead>
<tr>
  <th>Query-String Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog.  Not required, but the broker could make use of this to locate the resource.
</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog.  Not required, but the broker could make use of this to locate the resource.</td>
</tr>
</tbody>
</table>

A response code of `200 OK` with a body of `{}` indicates that the resource was deleted. A response code of `404 Not Found` with a body of `{}` indicates to Cloud Controller that the resource was not there in the first place, and is likely gone. _Any other_ response code indicates to Cloud Controller that the the binding could not be deleted; the user will be informed (and the binding will remain in the database).

## <a id='unprovisioning'></a>Unprovisioning ##

When a broker receives an unprovision request from Cloud Controller, it should delete any resources it created during the provision. Usually this means that all resources are immediately reclaimed for future provisions.

`DELETE /v2/service_instances/:id`

The `:id` in the URL is the identifier returned in by the broker during a provision response.  The request has **no body**, because DELETE requests generally do not have bodies. It does provide these query string params as useful hints for brokers:


<table>
<thead>
<tr>
  <th>Query-String Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog.  Not required, but the broker could make use of this to locate the resource.
</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog.  Not required, but the broker could make use of this to locate the resource.</td>
</tr>
</tbody>
</table>

A response code of `200 OK` with a body of `{}` indicates that the resource was deleted. A response code of `404 Not Found `with a body of `{}` indicates to Cloud Controller that the resource was not there in the first place, and is likely gone. _Any other_ response code indicates to Cloud Controller that the the service instance could not be deleted, the user will be informed (and the instance will remain in the database).

## <a id='broker-errors'></a>Broker Errors ##

When a broker fails to perform any requested operation, unless it fails with a well-defined HTTP response code listed above (like 404 on delete), it should return a JSON-encoded error payload. This payload allows the broker to expose a message to end-user or operator. Any responses not matching this error format will result in the user seeing a generic internal error message.

* Use HTTP status code `400 Bad Request` when the input is syntactically invalid.
* Use HTTP status code `401 Unauthorized` when authentication is missing.
* Use HTTP status code `403 Forbidden` when authentication is incorrect.
* Use HTTP status code `422 Unprocessable Entity` when the input is semantically invalid.
* Use HTTP status code `502 Bad Gateway` when there is an issue with a downstream API.
* Use HTTP status code `500 Internal Server Error` for a generic issue.

**Error response format:**


<table>
<thead>
<tr>
  <th>Response Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>smessage*</td>
  <td>string</td>
  <td>An error message explaining why the request failed. This message will likely be forwarded to the person initiating the request.
</td>
</tr>
</tbody>
</table>

## <a id='orphans'></a>Orphans ##

The Cloud Controller database and a Broker are expected to store identical copies of existing instances and bindings. Potentially, these two lists may become inconsistent. For example, if a broker times out during a delete request, the Cloud Controller will be unsure of whether that resource still exists on the broker or not. Cloud Controller will implement the following orphan prevention techniques:

* If a broker fails to provision or bind an instance, the Cloud Controller will immediately issue an unprovision or unbind request .

* If a broker fails to unbind or unprovision an instance, the Cloud Controller will periodically retry that DELETE request until it succeeds (or generates a 404). Eventually it will give up, but this technique will help clean up resources that are remain when a broker fails to delete.

